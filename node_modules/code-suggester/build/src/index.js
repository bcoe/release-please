"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTextFiles = exports.createPullRequest = exports.reviewPullRequest = void 0;
const handler = require("./github-handler");
const types_1 = require("./types");
const logger_1 = require("./logger");
const default_options_handler_1 = require("./default-options-handler");
const retry = require("async-retry");
/**
 * Given a set of suggestions, make all the multiline inline review comments on a given pull request given
 * that they are in scope of the pull request. Outof scope suggestions are not made.
 *
 * In-scope suggestions are specifically: the suggestion for a file must correspond to a file in the remote pull request
 * and the diff hunk computed for a file's contents must produce a range that is a subset of the pull request's files hunks.
 *
 * If a file is too large to load in the review, it is skipped in the suggestion phase.
 *
 * If changes are empty then the workflow will not run.
 * Rethrows an HttpError if Octokit GitHub API returns an error. HttpError Octokit access_token and client_secret headers redact all sensitive information.
 * @param octokit The authenticated octokit instance, instantiated with an access token having permissiong to create a fork on the target repository.
 * @param diffContents A set of changes. The changes may be empty.
 * @param options The configuration for interacting with GitHub provided by the user.
 * @param loggerOption The logger instance (optional).
 * @returns the created review's id number, or null if there are no changes to be made.
 */
async function reviewPullRequest(octokit, diffContents, options, loggerOption) {
    logger_1.setupLogger(loggerOption);
    // if null undefined, or the empty map then no changes have been provided.
    // Do not execute GitHub workflow
    if (diffContents === null ||
        diffContents === undefined ||
        (typeof diffContents !== 'string' && diffContents.size === 0)) {
        logger_1.logger.info('Empty changes provided. No suggestions to be made. Cancelling workflow.');
        return null;
    }
    const gitHubConfigs = default_options_handler_1.addReviewCommentsDefaults(options);
    const remote = {
        owner: gitHubConfigs.owner,
        repo: gitHubConfigs.repo,
    };
    const reviewNumber = await handler.reviewPullRequest(octokit, remote, gitHubConfigs.pullNumber, gitHubConfigs.pageSize, diffContents);
    return reviewNumber;
}
exports.reviewPullRequest = reviewPullRequest;
/**
 * Make a new GitHub Pull Request with a set of changes applied on top of primary branch HEAD.
 * The changes are committed into a new branch based on the upstream repository options using the authenticated Octokit account.
 * Then a Pull Request is made from that branch.
 *
 * Also throws error if git data from the fork is not ready in 5 minutes.
 *
 * From the docs
 * https://developer.github.com/v3/repos/forks/#create-a-fork
 * """
 * Forking a Repository happens asynchronously.
 * You may have to wait a short period of time before you can access the git objects.
 * If this takes longer than 5 minutes, be sure to contact GitHub Support or GitHub Premium Support.
 * """
 *
 * If changes are empty then the workflow will not run.
 * Rethrows an HttpError if Octokit GitHub API returns an error. HttpError Octokit access_token and client_secret headers redact all sensitive information.
 * @param {Octokit} octokit The authenticated octokit instance, instantiated with an access token having permissiong to create a fork on the target repository
 * @param {Changes | null | undefined} changes A set of changes. The changes may be empty
 * @param {CreatePullRequestUserOptions} options The configuration for interacting with GitHub provided by the user.
 * @param {Logger} logger The logger instance (optional).
 * @returns {Promise<number>} the pull request number. Returns 0 if unsuccessful.
 */
async function createPullRequest(octokit, changes, options, loggerOption) {
    logger_1.setupLogger(loggerOption);
    // if null undefined, or the empty map then no changes have been provided.
    // Do not execute GitHub workflow
    if (changes === null || changes === undefined || changes.size === 0) {
        logger_1.logger.info('Empty change set provided. No changes need to be made. Cancelling workflow.');
        return 0;
    }
    const gitHubConfigs = default_options_handler_1.addPullRequestDefaults(options);
    logger_1.logger.info('Starting GitHub PR workflow...');
    const upstream = {
        owner: gitHubConfigs.upstreamOwner,
        repo: gitHubConfigs.upstreamRepo,
    };
    const origin = options.fork === false ? upstream : await handler.fork(octokit, upstream);
    const originBranch = {
        ...origin,
        branch: gitHubConfigs.branch,
    };
    const refHeadSha = await retry(async () => await handler.branch(octokit, origin, upstream, originBranch.branch, gitHubConfigs.primary), {
        retries: 5,
        factor: 2.8411,
        minTimeout: 3000,
        randomize: false,
        onRetry: () => {
            logger_1.logger.info('Retrying at a later time...');
        },
    });
    await handler.commitAndPush(octokit, refHeadSha, changes, originBranch, gitHubConfigs.message, gitHubConfigs.force);
    const description = {
        body: gitHubConfigs.description,
        title: gitHubConfigs.title,
    };
    const prNumber = await handler.openPullRequest(octokit, upstream, originBranch, description, gitHubConfigs.maintainersCanModify, gitHubConfigs.primary);
    logger_1.logger.info(`Successfully opened pull request: ${prNumber}.`);
    return prNumber;
}
exports.createPullRequest = createPullRequest;
/**
 * Convert a Map<string,string> or {[path: string]: string}, where the key is the relative file path in the repository,
 * and the value is the text content. The files will be converted to a Map also containing the file mode information '100644'
 * @param {Object<string, string | null> | Map<string, string | null>} textFiles a map/object where the key is the relative file path and the value is the text file content
 * @returns {Changes} Map of the file path to the string file content and the file mode '100644'
 */
function parseTextFiles(textFiles) {
    const changes = new Map();
    if (textFiles instanceof Map) {
        textFiles.forEach((content, path) => {
            if (typeof path !== 'string' ||
                (content !== null && typeof content !== 'string')) {
                throw TypeError('The file changeset provided must have a string key and a string/null value');
            }
            changes.set(path, new types_1.FileData(content));
        });
    }
    else {
        for (const [path, content] of Object.entries(textFiles)) {
            if (typeof path !== 'string' ||
                (content !== null && typeof content !== 'string')) {
                throw TypeError('The file changeset provided must have a string key and a string/null value');
            }
            changes.set(path, new types_1.FileData(content));
        }
    }
    return changes;
}
exports.parseTextFiles = parseTextFiles;
//# sourceMappingURL=index.js.map